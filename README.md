# 🏃 helparty

## ✋ 소개

Helparty는 ‘Health + Help + Partner + Party’ 의 합성어 나를 도와주는 파트너들과 함께 헬스를 할수있도록 하는 Headless 기반의 서비스입니다.
헬스를 한번이라도 해본 사람은 파트너가 있을 때와 없을 때의 운동효과 차이를 극명히 느낄 수 있습니다.
파트너와의 약속, 벤치 프레스를 하나라도 더 칠 수 있게 하는 파트너의 존재, 새로운 운동을 배우고, 자세를 바로잡을 수 있는 파트너와의 지식공유는 근성장에 아주 큰 영향을 끼칩니다.
운동 일정, 시간, 장소, 수행 능력, MBTI, 신체정보, 주 운동 부위 등의 지표를 통해 나에게 맞는 파트너를 컨텍할 수 있는 API를 제공합니다.

## 🥅 프로젝트 목표

### 1. 배운 내용에 대한 산출물

회사를 퇴사하고 강의와 책, 멘토링을 통해 JPA와 TDD를 공부했습니다. 그리고 이를 기반으로 한 산출물을 만들어내기 위해 토이 프로젝트를 계획했습니다.
이 외에도 사용해보지 않았던 기술을 추가 도입하여 프로젝트를 완성하는 것이 목표였기에 Headless 기반으로 설계하였습니다.

### 2. DevOps 생태계 구축

컨테이너를 통한 리소스 관리, 빌드/배포 자동화를 위해 Docker와 Jenkins를 도입했습니다. 포스팅된 자료들을 그대로 따라하면 쉽게 컨테이너 기반의 CI/CD 환경을 구축할 수 있지만,
컨테이너의 동작 과정과 개념을 이해하긴 힘들다고 판단하였습니다. 그래서 강의를 통해 먼저 배워 사용하는 기술에 대해 충분히 이해한 후 프로젝트에 적용하였고, 요소가 추가될때마다
인프라 구조도를 업데이트 해 나가며 시스템이 어떻게 상호작용하는지 이해하려 노력했습니다.
![image](https://github.com/tlatmsrud/hellparty/assets/9374562/d84d9984-fca5-45f7-b591-f739bafd1cbc)



## 📅 개발기간
2023-07-01 ~ 2023-08-15

## ⛰️ 개발환경
- IDE : intellij
- Language : java
- Framework : SpringBoot 3.0
- JDK Version : JDK 17
- DB : H2, Mysql
- SCM : Git

## ✏️ 기술스택
- SpringBoot 3.0
- Spring WebSocket - 채팅 기능(내장 메시지 브로커 사용)
- Redis - 채팅내역 캐싱
- JPA - ORM 기술 익히기
- H2, Mysql - 처음은 Oracle을 도입했으나, 서버 PC의 메모리가 낮은 관계로 Mysql로 변경
- Docker - 컨테이너 환경 이해 및 도입
- Jenkins - CI/CD, Git webHook을 트리거로한 자동배포
- SonarQube - 코드 정적 분석을 통한 리팩토링이 주 목적
- OAuth2 - 네이버, 카카오, 구글 로그인
- Gradle - 빌드
- Asciidoc, restdocs - API 명세서 작성
- Junit5 - 단위테스트 작성

## 🤔 프로젝트 회고
### TDD를 통한 객체지향적 사고 향상
   어떤 메서드에 대한 테스트 코드를 작성할때 '이 메서드는 구체적으로 어떤 기능을 수행하지?' 라는 생각이 가장 먼저 들었습니다. 너무 많은 기능을 담고있다면 테스트의 범위가 커지고,
   신뢰성 있는 테스트라고 보기 어렵기 때문입니다. 성격이 다른 로직이 혼재되거나 해당 로직이 재사용될 여지가 있다면 책임을 분리하는것을 자연스럽게 고려하게 되었습니다.
   DB와 Redis에서 채팅 내역을 조회하는 기능이 있습니다. 기능 구현만 생각했을 때는 DB는 JPARepository를, Redis는 RedisTemplate을 통해 처리하면 된다라고 생각했습니다.
   테스트 코드를 작성하니 RedisTemplate을 Mocking하거나 의존시켜야 했고, 결과적으로 이 메서드의 기능은 'DB에 저장된 채팅내역 + Redis에 저장된 채팅내역' 이 아닌 'DB에 저장된 채팅내역 + RedisTemplate을 통한 통신 + 데이터 가공' 이었고, Redis를 사용하는 모든 클래스에서 RedisTemplate을 의존해야 함을 빠르게 알 수 있었습니다. 이를 근거로 RedisTemplate을 사용하여 CRUD를 처리하는 책임을 갖는 RedisService 클래스를 만들었습니다.
   결과적으로 해당 메서드는 'DB와 Redis에서 채팅 내역을 조회하고 병합한다'는 책임을 갖게 되었고, 테스트도 Mocking을 통해 간단하게 구현할 수 있었습니다.

---

### Swagger의 단점을 극복하는 restdocs 와 asciidoc 의 사용
   Swagger를 사용하면 쉬운 사용법을 기반으로 깔끔한 API 인터페이스를 제공할 수 있지만, DTO와 Controller에 Swagger 연동을 위한 코드가 필연적으로 들어가야 했습니다. 코드가 지저분해지는 것도 있지만, 어플리케이션 코드에
   외부 모듈의 코드가 들어가는 것이 마음에 들지 않았습니다.
   이에 대한 대안으로 restdocs와 asciidoc을 도입하게 되었고, 앞서 언급한 단점을 극복할 수 있게 되었습니다.
   
   ![image](https://github.com/tlatmsrud/hellparty/assets/9374562/4019b523-2f27-490d-821a-035df3955055)

---

### 이쉬움이 남는 JPA 활용
   JPA를 통해 DDD를 경험하고, Spring Data JPA와 QueryDSL을 사용하여 데이터 처리를 하였습니다. 산출물을 내기 위한것이 목적이었기 때문에 실제 서비스했을 때 발생할 수 있는 JPA의 문제 상황들을 경험하지 못한것이 아쉽습니다.
   곧 동료 프론트엔드 개발자와 협업을 통해 실제 서비스를 목표로 어플리케이션 개발을 계획중입니다. 그때 이 아쉬움을 해소하고 성장하겠습니다.

---

### 근거를 기반으로 한 다양한 기술 사용
   무조건적인 기술 도입을 지양하고 근거를 기반으로 도입하였습니다.


#### 1. 세션이 아닌 JWT를 도입한 이유
세션을 사용할 경우 서버 내에 세션을 관리하기 위한 메모리가 사용되며, 클라이언트의 정보를 서버에서 저장하는 연결성을 갖게 됩니다. 만약 서버가 한대라면 문제가 되지 않지만, 다중 서버라면 세션 관리 정책을 수립해야합니다.
세션 클러스터링을 할 경우 클러스터링 서버를 구축 및 연동을 해야하고, sticky 세션 정책을 적용할 경우 한쪽 서버가 다운됐을 시 해당 서버에 접속해있던 사용자의 접속이 모두 끊기게 됩니다.
하지만 JWT를 사용하면 서버에서 따로 토큰을 관리할 필요도 없고, 한쪽 서버가 다운되도 사용자의 접속도 유지됩니다. 세션보다 비용과 서비스 운영 측면에서 이점을 갖고 있어 도입했습니다.


#### 2. yml 정보를 jasypt로 암호화 한 이유
yml에는 DB 접속정보나 JWT 키 값 등 보안이 필요한 정보들이 들어있습니다. Git에 public 리포지토리로 이 정보가 올라가게 되면 보안 문제가 발생할 수 있으니 yml 자체를 gitignore 에 포함시켜 git에서 관리하지 못하도록 처리할 수 있지만,
타 개발자와의 협업 시 로컬 개발을 위해 yml 파일을 따로 전달하거나 해당 정보를 알려줘야하는 단점이 있습니다. fork받은 후 환경 변수만 설정하고 바로 어플리케이션을 실행할 수 있도록 jasypt를 도입했습니다.


#### 3. JWT Refresh Token을 Redis에서 관리하는 이유
Redis는 Key, Value 형식의 메모리 데이터 저장소입니다. DB보다 속도가 빠르며 데이터마다 TTL을 지정할 수 있습니다.
JWT RefreshToken의 경우 사용자 ID마다 할당되어 있고, Timeout 값을 갖습니다. DB에서 관리될 경우 Redis보다 속도가 느리고, 스케줄링을 통해 RefreshToken을 수시로 지워줘야하는 작업이 필요했습니다.
관리 측면에서 Redisrk 적합하다고 판단하여 도입했습니다.


#### 4. 채팅내역 임시 보관을 Redis에서 하는 이유
채팅을 입력할 때마다 실시간으로 채팅내역을 저장해야 합니다. 많은 쓰기 작업으로 인한 트랜잭션 증가로 DB의 부하 예상되었습니다. 해서 채팅내역은 먼저 Redis에 저장하고, 새벽 시간대에 Quartz를 통해
Redis에 있는 채팅 내역을 DB로 이관하도록 하였습니다.


#### 5. 채팅 기능 구현을 위해 웹소켓을 도입한 이유
HTTP는 TCP/IP 기반이며 요청마다 Connection을 맺고 닫아버리는 반면, 웹 소켓의 경우 Connection을 유지하는 특성을 갖고 있습니다. Connection을 맺고 끊는 시간을 아껴 빠른 통신을 가능케 하고,
양방향 통신이라 데이터를 서버에게 요청하지 않아도 서버가 클라이언트에게 데이터를 실시간으로 전달할 수 있습니다. 이런 특성이 채팅기능과 유사했기에 웹소켓을 도입하였으며, 1대1 채팅을 기능을 위한 메시지 브로커를
제공하는 스프링 웹소켓을 도입하게 되었습니다.

      
    
    
   
   
    
    
   
    
   
   
